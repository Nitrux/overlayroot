#!/bin/sh
#  Copyright, 2012 Dustin Kirkland <kirkland@ubuntu.com>
#  Copyright, 2012 Scott Moser <smoser@ubuntu.com>
#  Copyright, 2012 Axel Heider
#  Copyright, 2025 Uri Herrera <uri_herrera@nxos.org>
#
#  Based on scripts from
#    Sebastian P.
#    Nicholas A. Schembri State College PA USA
#    Axel Heider
#    Dustin Kirkland
#    Scott Moser
#
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see
#    <http://www.gnu.org/licenses/>.

case "$1" in
	prereqs) echo ""; exit 0;;
esac

# shellcheck source=/dev/null
. /scripts/functions

PATH=/usr/sbin:/usr/bin:/sbin:/bin
MYTAG="overlayroot"

TEMP_D="${TMPDIR:-/tmp}/${0##*/}.configs"
VARIABLES="overlayroot"

root_rw=/media/root-rw
root_ro=/media/root-ro

# shellcheck disable=SC2154
ROOTMNT=${rootmnt}
OVERLAYROOT_DEBUG=0

PERSIST_DIR=/run/initramfs

if [ ! -d "$PERSIST_DIR" ] && [ -d /dev/.initramfs ]; then
	PERSIST_DIR="/dev/.initramfs"
fi

if [ ! -d "$PERSIST_DIR" ]; then
	mkdir -p "$PERSIST_DIR" ||
		echo "WARNING: $MYTAG: failed to create ${PERSIST_DIR}" 1>&2
fi

LOG_FILE="${PERSIST_DIR}/${MYTAG}.log"

# shellcheck disable=SC3043
log() {
	local level="$1"; shift
	"log_${level}_msg" "$MYTAG: $*"
	_debug "[$level]:" "$@"
}

log_fail()    { log failure "$@"; }
log_success() { log success "$@"; }
log_warn()    { log warning "$@"; }

fail() {
	[ $# -eq 0 ] || log_fail "$@";
	exit 1;
}

# shellcheck disable=SC2329
cleanup() {
	[ -d "${TEMP_D}" ] && rm -Rf "${TEMP_D}"
}

debug() {
	_debug "$@"
	[ "${OVERLAYROOT_DEBUG:-0}" = "0" ] && return
	echo "$MYTAG:" "$@"
}

_debug() {
	[ "${DEBUG_BUSTED:-0}" = 1 ] && return
		{ echo "$@" >> "$LOG_FILE"; } 2>/dev/null || {
			DEBUG_BUSTED=1; log_warn "debug is busted"
	}
}


# shellcheck disable=SC3043
# shellcheck disable=SC2295
safe_string() {
	local prev="$1" allowed="$2" cur=""
	[ -n "$prev" ] || return 1
	while cur="${prev#[${allowed}]}"; do
		[ -z "$cur" ] && return 0
		[ "$cur" = "$prev" ] && break
		prev="$cur"
	done
	return 1
}

# shellcheck disable=SC3043
# shellcheck disable=SC2086
# shellcheck disable=SC2295
parse_string() {
	local input="${1}" delim="${2:-,}" ns="${3:-_RET_}"
	local oifs="$IFS" tok="" keys="" key="" val="" val_escaped=""

	set -f; IFS="$delim"; set -- $input; IFS="$oifs"; set +f
	_RET=""
	for tok in "$@"; do
		key="${tok%%=*}"
		val="${tok#${key}}"
		val=${val#=}

		safe_string "$key" "0-9a-zA-Z_" ||
			{ debug "$key not a safe variable name"; return 1; }

		case "$val" in
			*[!a-zA-Z0-9_,-=:%/.]*)
				debug "$val contains unsafe characters"; return 1 ;;
		esac

		val_escaped=$(printf "%s" "$val" | sed "s/'/'\\\\''/g")
		eval "${ns}${key}='${val_escaped}'" || return 1
		keys="${keys} ${ns}${key}"
	done
	_RET=${keys# }
	return
}

# shellcheck disable=SC3043
# shellcheck disable=SC2295
write_kernel_cmdline_cfg() {
	local cfg="$1" desc="${2:-kernel cmdline}"
	local cmdline="" var="" val="" val_escaped="" tok=""
	read -r cmdline < /proc/cmdline || return 1
	: > "${cfg}" || return
	set -f
	{
		echo "desc='${desc}'"
		for tok in $cmdline; do
			for var in $VARIABLES; do
				if [ "$tok" = "$var" ]; then
					log_warn "kernel param without value '${tok}'"; continue
				elif [ "$tok" = "${var}=" ]; then
					echo "${var}=''"
				elif [ "${tok#${var}=}" != "${tok}" ]; then
					val="${tok#${var}=}"
					val_escaped=$(printf "%s" "$val" | sed "s/'/'\\\\''/g")
					echo "${var}='${val_escaped}'"
				fi
			done
		done
	} >> "$cfg"
	set +f
}

# shellcheck disable=SC3043
clean_path() {
	local p="$1" tmp=""
	while [ "${p#*//}" != "$p" ]; do
		tmp=${p#*//}
		p="${p%%//*}/${tmp}"
	done
	_RET="$p"
}

# shellcheck disable=SC3043
get_workdir() {
	local root_rw="$1" dir_prefix="$2" file="$3"
	file=${file%/}
	if [ "$file" = "/" ] || [ "$file" = "" ]; then
		file="_"
	fi
	clean_path "${root_rw}/${dir_prefix%/}-workdir/${file}"
}

# shellcheck disable=SC3043
# shellcheck disable=SC2034
# shellcheck disable=SC2295
# shellcheck disable=SC2086
overlayrootify_fstab() {
	local input="$1" root_ro="${2:-/media/root-ro}"
	local root_rw="${3:-/media/root-rw}" dir_prefix="${4:-/}"
	local recurse="${5:-1}" swap="${6:-0}" fstype="${7:-overlay}"
	local hash="#" oline="" ospec="" upper="" dirs="" copy_opts="" copy_opt=""
	local spec file vfstype opts pass freq line ro_line
	local workdir="" use_orig="" need_workdir=false noauto="" ro_opts=""
	[ -f "$input" ] || return 1
	cat <<EOF
#
#  This fstab is for overlayroot. You can find the real file at
#  ${root_ro}/etc/fstab
#  The original entry for '/' and other mounts has been updated to be placed
#  under $root_ro.
#  To permanently modify this (or any other file), you should change-root into
#  a writable view of the underlying filesystem using:
#      sudo overlayroot-chroot
#
EOF
	if needs_workdir; then need_workdir=true; else need_workdir=false; fi
	while read -r spec file vfstype opts pass freq; do
		[ "$file" = "/" ] && noauto="noauto" || noauto=""
		line="$spec $file $vfstype $opts $pass $freq"
		case ",$opts," in
			*,ro,*) ro_opts="$opts";;
			*) if [ -n "$opts" ]; then ro_opts="ro,$opts"; else ro_opts="ro"; fi;;
		esac
		ro_line="$spec ${root_ro}$file $vfstype"
		ro_line="${ro_line} ${ro_opts}${noauto:+,${noauto}} $pass $freq"
		use_orig=""
		if [ "${spec#${hash}}" != "$spec" ]; then
			use_orig="comment"
		elif [ -z "$freq" ]; then
			use_orig="malformed-line"
		else
			case "$vfstype" in
				vfat|fat) use_orig="fs-unsupported";;
				proc|sys|tmpfs|dev|udev|debugfs) use_orig="fs-virtual";;
			esac
		fi
		if [ -n "$use_orig" ]; then
			if [ "$use_orig" != "comment" ]; then
				echo "$line # $MYTAG:$use_orig"
			else
				echo "$line"
			fi
		elif [ "$vfstype" = "swap" ]; then
			if [ "$swap" = "0" ]; then
				echo "#$MYTAG:swap=${swap}#${line}"
			elif [ "${spec#/}" != "${spec}" ] && [ "${spec#/dev/}" = "${spec}" ]; then
				echo "#$MYTAG:swapfile#${line}"
			else
				echo "${line}"
			fi
		else
			ospec="${root_ro}${file}"
			copy_opts=""
			for copy_opt in nobootwait noauto; do
				case ",$opts," in
					*,${copy_opt},*) copy_opts="${copy_opts},${copy_opt}";;
				esac
			done
			clean_path "${root_rw}/${dir_prefix}${file}"
			upper="$_RET"
			oline="${ospec} ${file} $fstype "
			clean_path "${root_ro}${file}"
			oline="${oline}lowerdir=$_RET"
			oline="${oline},upperdir=${upper}${copy_opts}"
			if [ "$fstype" = "overlay" ] && [ "${need_workdir}" = "true" ]; then
				get_workdir "$root_rw" "$dir_prefix" "$file"
				workdir="$_RET"
				oline="${oline},workdir=$workdir"
				dirs="${dirs} $workdir"
			fi
			oline="${oline} $pass $freq"
			if [ "$recurse" != "0" ] || [ "$file" = "/" ]; then
				echo "#$ro_line"
				echo "$oline"
				dirs="${dirs} ${upper}"
			else
				echo "$line"
			fi
		fi
	done < "$input"
	_RET=${dirs# }
}

# shellcheck disable=SC3043
# shellcheck source=/dev/null
# shellcheck disable=SC2154
readcfgd() {
	local cfg_d="$1"
	local or=""
	_RET_desc_oroot=""
	set +f
	for f in "${cfg_d}"/*; do
		. "$f" || fail "failed reading $f"
		[ "$or" != "${overlayroot}" ] &&
		_RET_desc_oroot="$desc"
		or=${overlayroot}
	done
	set -f
}

needs_workdir() {
    return 0
}

cfgd="${TEMP_D}/configs"
mkdir -p "${cfgd}" || fail "failed to create tempdir"
type cleanup >/dev/null 2>&1 && trap cleanup EXIT

{
	echo "desc='builtin'"
	echo "overlayroot=''"
} > "$cfgd/00-builtin"

write_kernel_cmdline_cfg "${cfgd}/90-kernel" ||
	fail "failed to read kernel command line!"

readcfgd "$cfgd" ||
	fail "reading configs failed"
used_desc="${_RET_desc_oroot}"

opts=""
cfgmsg="${used_desc:+ (per ${used_desc})}"

case "$overlayroot" in
	tmpfs|tmpfs:*)
		mode="tmpfs"
		opts="${overlayroot#tmpfs}";
		opts=${opts#:}
		;;
	*)
		debug "overlayroot disabled${cfgmsg}"
		exit 0;;
esac

parse_string "$opts" "," _RET_common_
swap=${_RET_common_swap:-0}
recurse=${_RET_common_recurse:-1}
OVERLAYROOT_DEBUG=${_RET_common_debug:-${OVERLAYROOT_DEBUG}}
dir_prefix=${_RET_common_dir:-"/overlay"}

# shellcheck disable=SC2154
tmpfs_size=${_RET_common_size}

overlayroot_driver=overlay

debug "swap=$swap recurse=$recurse debug=$OVERLAYROOT_DEBUG dir=$dir_prefix"
debug "mode=$mode driver=${overlayroot_driver}"

[ "$swap" != "0" ] && [ "$swap" != "1" ] &&
    fail "invalid setting for swap: $swap. must be '0' or '1'"
[ "$recurse" != "0" ] && [ "$recurse" != "1" ] &&
    fail "invalid setting for recurse: $recurse. must be '0' or '1'"

log_warn "configuring overlayroot with driver=${overlayroot_driver} mode=$mode opts='$opts' per $used_desc"

workdir=""
mount_type="overlay"
ovl_opts="lowerdir=${root_ro},upperdir=${root_rw}/${dir_prefix}"
if needs_workdir; then
	get_workdir "$root_rw" "$dir_prefix" "/"
	workdir="$_RET"
	ovl_opts="${ovl_opts},workdir=${workdir}"
fi

mkdir -p "${root_rw}" ||
	fail "failed to create ${root_rw}"

mkdir -p "${root_ro}" ||
	fail "failed to create ${root_ro}"

if [ "$mode" = "tmpfs" ]; then
    tmp_opts="mode=0755,nodev,nosuid,noexec"
    [ -n "${tmpfs_size:-}" ] && tmp_opts="size=${tmpfs_size},${tmp_opts}"
    mount -t tmpfs -o "$tmp_opts" tmpfs-root "$root_rw" || fail "failed to create tmpfs"
else
    log_fail "Invalid mode '$mode' detected. Only 'tmpfs' is supported."
    panic "$MYTAG"
fi

mkdir -p "${root_rw}/${dir_prefix}" ||
	fail "failed to create ${dir_prefix} on ${root_rw}"

[ -z "$workdir" ] || mkdir -p "$workdir" ||
	fail "failed to create workdir '$workdir' on ${root_rw}"

mount --move "${ROOTMNT}" "${root_ro}" ||
	fail "failed to move root away from ${ROOTMNT} to ${root_ro}"

# shellcheck disable=SC2086
debug mount -t "$mount_type" -o "$ovl_opts" overlayroot "$ROOTMNT"

# shellcheck disable=SC2086
if ! mount -t "$mount_type" -o "$ovl_opts" overlayroot "$ROOTMNT"; then
	log_fail "failed to create new ro/rw layered ${ROOTMNT}"
	log_fail "mount command was: mount -t $mount_type -o $ovl_opts overlayroot $ROOTMNT"
	if ! mount --move "${root_ro}" "${ROOTMNT}"; then
		log_fail "RECOVERY_ERROR: failed to move $root_ro back to ${ROOTMNT}"
		panic "$MYTAG"
	fi
	exit 0
fi

mkdir -p "${ROOTMNT}/${root_ro}"
mount --move "${root_ro}" "${ROOTMNT}${root_ro}" ||
	fail "failed to move ${root_ro} to ${ROOTMNT}${root_ro}"

[ -d "${ROOTMNT}${root_rw}" ] || mkdir -p "${ROOTMNT}${root_rw}"
mount --move "${root_rw}" "${ROOTMNT}${root_rw}" ||
	fail "failed to move ${root_rw} to ${ROOTMNT}${root_rw}"

source_fstab="$ROOTMNT/${root_ro}/etc/fstab"
if [ -f "$source_fstab" ]; then
	overlayrootify_fstab "$source_fstab" "$root_ro" \
		"$root_rw" "$dir_prefix" "$recurse" "$swap" "${overlayroot_driver}" \
		> "${ROOTMNT}/etc/fstab" ||
		log_fail "failed to modify /etc/fstab"
else
    debug "rootfs did not contain /etc/fstab. Skipping."
fi

for d in ${_RET}; do
	mkdir -p "${ROOTMNT}/$d"
done

if grep -qw ro /proc/cmdline; then
	mount -o remount,ro "$ROOTMNT" || log_warn "failed to remount $ROOTMNT ro"
	debug "mounted $ROOTMNT read-only per kernel cmdline"
fi

msg="configured root with '$overlayroot' using ${overlayroot_driver} per"
msg="$msg ${used_desc}"
log_success "$msg"

exit 0
